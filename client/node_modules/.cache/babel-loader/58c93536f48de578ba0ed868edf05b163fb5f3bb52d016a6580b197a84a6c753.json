{"ast":null,"code":"const SemVer = require('../classes/semver');\nconst parse = require('./parse');\nconst {\n  re,\n  t\n} = require('../internal/re');\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version;\n  }\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n  if (typeof version !== 'string') {\n    return null;\n  }\n  options = options || {};\n  let match = null;\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE]);\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next;\n    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1;\n  }\n  if (match === null) {\n    return null;\n  }\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options);\n};\nmodule.exports = coerce;","map":{"version":3,"names":["SemVer","require","parse","re","t","coerce","version","options","String","match","rtl","COERCE","next","COERCERTL","exec","index","length","lastIndex","module","exports"],"sources":["/Users/tchevier3/Desktop/Github/Code-Crackdown/client/node_modules/semver/functions/coerce.js"],"sourcesContent":["const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAC3C,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAChC,MAAM;EAAEE,EAAE;EAAEC;AAAE,CAAC,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAE3C,MAAMI,MAAM,GAAG,CAACC,OAAO,EAAEC,OAAO,KAAK;EACnC,IAAID,OAAO,YAAYN,MAAM,EAAE;IAC7B,OAAOM,OAAO;EAChB;EAEA,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/BA,OAAO,GAAGE,MAAM,CAACF,OAAO,CAAC;EAC3B;EAEA,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/B,OAAO,IAAI;EACb;EAEAC,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIE,KAAK,GAAG,IAAI;EAChB,IAAI,CAACF,OAAO,CAACG,GAAG,EAAE;IAChBD,KAAK,GAAGH,OAAO,CAACG,KAAK,CAACN,EAAE,CAACC,CAAC,CAACO,MAAM,CAAC,CAAC;EACrC,CAAC,MAAM;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,IAAI;IACR,OAAO,CAACA,IAAI,GAAGT,EAAE,CAACC,CAAC,CAACS,SAAS,CAAC,CAACC,IAAI,CAACR,OAAO,CAAC,MACvC,CAACG,KAAK,IAAIA,KAAK,CAACM,KAAK,GAAGN,KAAK,CAAC,CAAC,CAAC,CAACO,MAAM,KAAKV,OAAO,CAACU,MAAM,CAAC,EAC9D;MACA,IAAI,CAACP,KAAK,IACJG,IAAI,CAACG,KAAK,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACI,MAAM,KAAKP,KAAK,CAACM,KAAK,GAAGN,KAAK,CAAC,CAAC,CAAC,CAACO,MAAM,EAAE;QACnEP,KAAK,GAAGG,IAAI;MACd;MACAT,EAAE,CAACC,CAAC,CAACS,SAAS,CAAC,CAACI,SAAS,GAAGL,IAAI,CAACG,KAAK,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACI,MAAM,GAAGJ,IAAI,CAAC,CAAC,CAAC,CAACI,MAAM;IAC1E;IACA;IACAb,EAAE,CAACC,CAAC,CAACS,SAAS,CAAC,CAACI,SAAS,GAAG,CAAC,CAAC;EAChC;EAEA,IAAIR,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,OAAOP,KAAK,CAAE,GAAEO,KAAK,CAAC,CAAC,CAAE,IAAGA,KAAK,CAAC,CAAC,CAAC,IAAI,GAAI,IAAGA,KAAK,CAAC,CAAC,CAAC,IAAI,GAAI,EAAC,EAAEF,OAAO,CAAC;AAC5E,CAAC;AACDW,MAAM,CAACC,OAAO,GAAGd,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}